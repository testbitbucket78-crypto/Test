import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { FormArray, FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { NgbModal, NgbModalRef } from '@ng-bootstrap/ng-bootstrap';
import { RichTextEditorComponent } from '@syncfusion/ej2-angular-richtexteditor';
import { DatePickerComponent } from '@syncfusion/ej2-angular-calendars';
import Drawflow from 'drawflow';
declare var bootstrap: any;
declare var $: any;
import { RichTextEditor } from '@syncfusion/ej2-angular-richtexteditor';
import { PhoneValidationService } from 'Frontend/dashboard/services/phone-validation.service';
import { TeamboxService } from 'Frontend/dashboard/services';



interface Attribute {
  name: string;
  label: string;
  type: 'text' | 'select' | 'multiselect' | 'switch' | 'number' | 'date';
  options?: { value: string, label: string }[];
}

@Component({
  selector: 'sb-card-creation',
  templateUrl: './card-creation.component.html',
  styleUrls: ['./card-creation.component.scss']
})
export class CardCreationComponent {
  showLock: any = true;
  nodeCounter: any = 1;
  selectedNodeId: number | null = null;
  cardType: string = '';
  filePreview: string | ArrayBuffer | null = null;
  fileError: string | null = null;
  orignalData: any = {};
  selectedType: string = 'Text';
  selectedImageUrl: any = '';
  isEditMode: boolean = false;
  currentModalRef: NgbModalRef | null = null;
  existingVariableNames: string[] = [];
  isFocused: boolean = false;
  MAX_OPTIONS = 20;
  MAX_BUTTONS = 3;
  MAX_SECTIONS = 5;
  MAX_ROWS_PER_SECTION = 10;

  // Common properties
  showValidationSettings = false;
  newOptionError = '';
  errorMessageLength = 0;
  questionTextLength = 0;
  bodyTextLength = 0;
  footerTextLength = 0;
  headerTextLength = 0;
  listHeaderLength = 0;
  delayTime: number = 10;
  delayUnit: string = 'minute';
  Tags: string[] = [];

  searchQuery = '';
  selectedAgentDetails: any | null = null;
  filteredAgents: any[] = [{ id: 1, name: 'James Watson' },
  { id: 2, name: 'David Harrison' },
  { id: 3, name: 'Jane Cooper' },
  { id: 4, name: 'Charles John' }];
  // File handling
  uploadedFile: File | null = null;
  selectedFileUrl: string | null = null;
  selectedFileType: string | null = null;

  @ViewChild('chatEditor') chatEditor!: RichTextEditorComponent;
  @ViewChild('questionEditor') questionEditor!: RichTextEditorComponent;
  @ViewChild('errorEditor') errorEditor!: RichTextEditorComponent;
  @ViewChild('minDatePicker') minDatePicker!: DatePickerComponent;
  @ViewChild('maxDatePicker') maxDatePicker!: DatePickerComponent;
  @ViewChild('bodyEditor') bodyEditor!: RichTextEditor;

  notificationForm!: FormGroup;

  availableAgents: any[] = [
    { id: '1', name: 'John Doe', status: 'active', email: 'john@example.com', phone: '+1234567890' },
    { id: '2', name: 'Jane Smith', status: 'inactive', email: 'jane@example.com', phone: '+1987654321' },
    // ... other agents
  ]; // Populate this from your API or service



  stringOperators = ['contains', 'does not contain', 'equals', 'not equal to', 'starts with', 'does not start with'];
  numberOperators = ['equals', 'not equal to', 'greater than', 'less than'];
  booleanOperators = ['is true', 'is false'];

  characterCount = 0;





  @Input() conditions: any[] = [];
  @Input() agents: any[] = [{ id: 1, name: 'James Watson' },
  { id: 2, name: 'David Harrison' },
  { id: 3, name: 'Jane Cooper' },
  { id: 4, name: 'Charles John' }

  ];
  @Output() conditionsChange = new EventEmitter<any[]>();

  @Input() availableAttributes: Attribute[] = [{ name: 'name', label: 'Name', type: 'text' },
  { name: 'email', label: 'Email', type: 'text' },
  {
    name: 'gender', label: 'Gender', type: 'select', options: [
      { value: 'male', label: 'Male' },
      { value: 'female', label: 'Female' }
    ]
  },];
  @Input() availableVariables: string[] = ['bot.name', 'contact.city', 'session.date'];
  @Output() save = new EventEmitter<any>();
  @Output() cancel = new EventEmitter<void>();
  @Input() selectedTags: string[] = [];
  @Output() tagsSelected = new EventEmitter<{ tags: string[], options: any }>();
  @Output() modalClosed = new EventEmitter<void>();

  @Output() timeDelaySet = new EventEmitter<{ time: number, unit: string }>();

  selectedAttribute: string = '';
  selectedValue: string = '';
  inputValue: string = '';
  selectedVariable: string = '';
  operation: string = 'replace';
  askQuestion: boolean = false;
  attributeDetails?: Attribute;

  joinType: 'AND' | 'OR' = 'AND';
  conditionForm!: FormGroup;
  contactAttributeForm!: FormGroup;
  operators = {
    string: ['Equals', 'Not Equals', 'Contains', 'Does not contain', 'Starts with', 'Does not start with'],
    number: ['Equals', 'Not Equals', 'Greater than', 'Less than', 'Greater than or equal', 'Less than or equal'],
    boolean: ['Is true', 'Is false'],
    date: ['Is', 'Is before', 'Is after']
  };

  sampleVariables = [
    { name: 'user.name', type: 'string', label: 'User Name', value: 'John Doe' },
    { name: 'user.email', type: 'string', label: 'User Email', value: 'Johan@gmail.com' },
    { name: 'user.age', type: 'number', label: 'User Age', value: 25 },
    { name: 'user.isPremium', type: 'boolean', label: 'Is Premium User', value: true },
    { name: 'user.joinDate', type: 'date', label: 'Join Date', value: '25/02/2025' },
    { name: 'bot.responseCount', type: 'number', label: 'Response Count', value: 25 },
    { name: 'bot.lastInteraction', type: 'date', label: 'Last Interaction', value: '25/02/2025' },
  ];

    attributeList = [
    { label: 'Age', name: 'user.age',value: 'user.age', type: 'number' },
    { label: 'Name', name: 'user.name',value: 'user.name', type: 'string' },
    { label: 'Subscribed', name: 'user.subscribed',value: 'user.subscribed', type: 'boolean' },

  ];
  attributes: any[] = [
    { name: 'name', label: 'Name', type: 'string' },
    { name: 'email', label: 'Email', type: 'string' },
    { name: 'age', label: 'age', type: 'number' },
    { name: 'date', label: 'Date', type: 'date' },
    { name: 'city', label: 'City', type: 'string' },
    {
      name: 'gender', label: 'Gender', type: 'select', options: [
        { value: 'male', label: 'Male' },
        { value: 'female', label: 'Female' }
      ]
    },
  ];

  variables: string[] = ['bot.name', 'contact.city', 'session.date',];

  showVarMenuFor: { index: number, field: 'comparator' | 'value' } | null = null;
  showAttribute: { index: number, field: 'comparator' | 'value' } | null = null;

  // @ViewChild('content') content: any;
  // @ViewChild('askButtonsModal') askButtonsModal: any;

  public tools: object = {
    items: ['Bold', 'Italic', 'StrikeThrough', 'EmojiPicker']
  };


  actions = [
    {
      icon: 'uil uil-share-alt', label: 'Assign Conversation to Agent',
      color: '#3b7ddd', modal: 'assignAgentModal'
    },
    { icon: 'uil uil-share-alt', label: 'Assign to Contact Owner', color: '#3b7ddd', modal: 'assigntoContactOwner' },
    { icon: 'uil uil-refresh', label: 'Unassign Conversation', color: '#5cac64', modal: 'UnassignConversation' },
    { icon: 'uil uil-refresh', label: 'Update Conversation Status', color: '#5cac64', modal: 'UpdateConversationStatus' },
    { icon: 'uil uil-refresh', label: 'Update Contact Attribute', color: '#5cac64', modal: 'UpdateContactAttribute' },
    { icon: 'uil uil-tag', label: 'Add Tags', color: '#d54c4c', modal: 'AddTags' },
    { icon: 'uil uil-tag', label: 'Remove Tag', color: '#d54c4c', modal: 'RemoveTag' },
    { icon: 'uil uil-schedule', label: 'Add Time Delay', color: '#5cac64', modal: 'TimeDelayModal' },
    { icon: 'uil uil-bolt', label: 'Trigger Bot', color: '#e67e22', modal: 'BotTriggerModal' },
    { icon: 'uil uil-bolt', label: 'Message Opt-in', color: '#16a085', modal: 'MessageOptin' },
    { icon: 'uil uil-funnel', label: 'Notify', color: '#8e44ad', modal: 'NotificationModal' },
  ];


  availableBots: any[] = [
    { id: 'bot1', name: 'Customer Support Bot', published: true },
    { id: 'bot2', name: 'Order Processing Bot', published: false },
    // ... other bots
  ];

  allTags: any[] = [
    { value: 'Search', label: 'Search', style: 'default' },
    { value: 'Paid', label: 'Paid', style: 'primary' },
    { value: 'Unpaid', label: 'Unpaid', style: 'danger' },
    { value: 'Return', label: 'Return', style: 'warning' },
    { value: 'New Customer', label: 'New Customer', style: 'success' },
    { value: 'Order Complete', label: 'Order Complete', style: 'info' },
    { value: 'New Order', label: 'New Order', style: 'purple' },
    { value: 'Unavailable', label: 'Unavailable', style: 'secondary' },
    { value: 'Buyer', label: 'Buyer', style: 'teal' },
    { value: 'Seller', label: 'Seller', style: 'pink' },
    { value: 'Hot Lead', label: 'Hot Lead', style: 'orange' }
  ];

  searchTerm: string = '';
  operationOptions: any = {
    addIfEmpty: false
  };

  maxCharacters: any = 1024
  conversationActions = { status: '' }


  public pasteCleanupSettings: object = {
    prompt: false,
    plainText: true,
    keepFormat: false,
  };

  sendTextForm!: FormGroup;
  questionOption!: FormGroup;
  openQuestion!: FormGroup;
  listOptions!: FormGroup;
  conditionsForm!: FormGroup;
  logicalOperator: string = 'and';
  buttonOptions!: FormGroup;
  userDetails: any
  basicTools = {
    items: ['Bold', 'Italic', 'StrikeThrough', 'EmojiPicker']
  };
  private editor: any;


  constructor(
    private fb: FormBuilder, public validation: PhoneValidationService, private apiService: TeamboxService,
  ) {
    this.userDetails = JSON.parse(sessionStorage.getItem('loginDetails')!);
    console.log("userDetails", this.userDetails);
  }



  zoomEditor(option: any) {
    if (option === 'zoom_out') {
      this.editor.zoom_out();
    } else if (option === 'zoom_in') {
      this.editor.zoom_in();
    } else {
      this.editor.zoom_reset();
    }
  }

  changeMode(option: any) {
    if (option === 'lock') {
      this.editor.editor_mode = 'edit';
      this.showLock = true;
    } else {
      this.editor.editor_mode = 'fixed';
      this.showLock = false;
    }
  }





  ngOnInit(): void {
    this.initEditor();
    this.initForms();
    // this.getAdditiionalAttributes()
  }

  initEditor() {
    const drawflowElement = document.getElementById('drawflow');
    if (drawflowElement) {
      this.editor = new Drawflow(drawflowElement);
      this.editor.start();

      // Zoom out initially
      const steps = 3;
      for (let i = 0; i < steps; i++) {
        this.editor.zoom_out();
      }

      this.editor.on('nodeSelected', (id: any) => {
        this.selectedNodeId = id;
      });

      this.editor.on('nodeRemoved', (id: any) => {
        this.selectedNodeId = null;
        const drawflowData = this.editor.export();
        const nodes: any = Object.values(drawflowData.drawflow.Home.data);
        if (nodes.length > 0) {
          this.editor.removeNodeInput(nodes[0]?.id, "input_1");
        }
      });
    }
  }


  ParentNodeType: any = ''
  openCreateModal(modalId: string, nodeType: string) {
    this.isEditMode = false;
    this.cardType = nodeType
    this.ParentNodeType = modalId


    Object.keys(this.sendTextForm.controls).forEach(key => {
      const control = this.sendTextForm.get(key);
      control?.clearValidators();
    });
    if (this.cardType === 'sendText') {
      const textControl = this.sendTextForm.get('textMessage');
      textControl?.setValidators([this.validation.richTextRequiredValidator(), Validators.maxLength(this.maxCharacters)]);
      textControl?.updateValueAndValidity(); // Don't forget this
    } else if (this.cardType === 'sendImage' || this.cardType === 'sendVideo' || this.cardType === 'sendDocument') {
      const fileControl = this.sendTextForm.get('file');
      const textControl = this.sendTextForm.get('textMessage');
      textControl?.setValidators([Validators.maxLength(this.maxCharacters)]);
      fileControl?.setValidators([Validators.required,]);
      fileControl?.updateValueAndValidity(); // Don't forget this
    }
    // Reset forms

    this.sendTextForm.get('file')?.reset(); // Clear form value
    this.sendTextForm.reset();
    this.questionOption.reset();
    const optionsArray = this.questionOption.get('options') as FormArray;
    optionsArray.clear(); // remove all existing entries
    optionsArray.push(this.fb.control(''));

    this.buttonOptions.reset();
    this.contactAttributeForm.reset()
    const buttonsArray = this.buttonOptions.get('buttons') as FormArray;
    buttonsArray.clear(); // remove all existing entries
    buttonsArray.push(this.fb.control(''));
    this.buttonOptions.get('headerType')?.setValue('none'); // Default to image  
    this.filePreview = null;
    this.selectedImageUrl = null;
    this.selectedTags = []
    this.selectedBotId = '';
    this.selectedBot = null

    if (modalId === 'Advance_Action') {
      this.openModal(this.cardType)
    } else {
      this.openModal(modalId)

    }
  }

  currentModal: any = null;
  onSubmit(FormType: any = ''): void {
    if (this.ParentNodeType === 'questionOption' || this.ParentNodeType === 'openQuestion' || this.ParentNodeType === 'buttonOptions' || this.ParentNodeType === 'listOptions') {
      this.handleQuestionSubmit(FormType);
    } else if (FormType == 'assignAgentModal' || FormType == 'assigntoContactOwner' || FormType == 'UnassignConversation' || FormType == 'UpdateConversationStatus' || FormType == 'UpdateContactAttribute' || FormType == 'AddTags' || FormType == 'RemoveTag' || FormType == 'TimeDelayModal' || FormType == 'BotTriggerModal' || FormType == 'MessageOptin' || FormType == 'NotificationModal') {
      this.advanceOptionsSubmit(FormType);
    } else {
      this.handleContentSubmit();
    }
  }

  handleContentSubmit() {
    if (this.sendTextForm.invalid) {
      this.sendTextForm.markAllAsTouched();
      return;
    }

    const formData = this.sendTextForm.value;

    if (this.isEditMode && this.selectedNodeId !== null) {
      this.updateExistingNode(formData);
    } else {
      this.createNewNodeWithData(formData);
    }
    this.closeModal()
  }



  createNewNodeWithData(formData: any) {
    let postData: any;
    const nodeName = this.getNodeName();

    const exportData = this.editor.export();
    const hasNodes = Object.keys(exportData.drawflow?.Home?.data).length > 0;
    const sectionRows = formData?.sections?.reduce((acc: any, section: any) => acc + (section.rows?.length || 0), 0) || 0;
    var outputs = (formData?.options?.length + 1 || formData?.buttons?.length + 1 || sectionRows + 1) || 1

    console.log("formData?.invalidAction", formData);

    if (formData?.invalidAction === "fallback") {
      outputs = outputs + 1
    }
    postData = {
      name: nodeName,
      inputs: hasNodes ? 1 : 0,
      outputs: outputs,
      data: {
        text: this.cardType,
        inputsCount: 1,
        maxButtonLimit: 3,
        category: this.ParentNodeType,
        uniqueId: this.getUniqueId(),
        formData: formData,
        file: formData.file,
        fileName: formData.file?.name || null,
        fileType: formData.file?.type || null,
      },
      html: '<div class="temp-placeholder">Loading...</div>',
      pos_x: Math.floor(Math.random() * (999 - 100 + 1)) + 100,
      pos_y: Math.floor(Math.random() * (499 - 100 + 1)) + 100,
    };

    const nodeId = this.addNode(postData);
    let newHTML = this.createNodeHtml(nodeId, postData.data);
    this.updateNodeHTML(Number(nodeId), newHTML);
    // this.addNodeEvent(Number(nodeId));
    if (this.ParentNodeType == 'listOptions') {
      this.setOutputPositionsforlist(nodeId, formData);
    } else {
      this.setOutputPositions(Number(nodeId), formData?.invalidAction);
    }
    this.nodeCounter++;
  }



  setOutputPositionsforlist(nodeId: any, formData: any) {
    const node = document.getElementById('node-' + nodeId);
    if (!node) return;

    const outputsContainer = node.querySelector('.outputs');
    const outputs: any = outputsContainer?.querySelectorAll('.output');
    if (!outputs || outputs.length === 0) return;

    // Always position the first output at the top
    const output1 = outputs[0];
    output1.style.position = 'absolute';
    output1.style.top = '20px';

    var remainingOutputs = Array.from(outputs).slice(1);
    if (formData?.invalidAction == "fallback") {
      const output2 = outputs[1];
      output2.style.position = 'absolute';
      output2.style.top = '41px'; // adjust as needed
      remainingOutputs = Array.from(remainingOutputs).slice(1);

    }


    // Start from bottom with calculated distance
    let bottomOffsets: number[] = [];
    bottomOffsets = this.generateBottomOffsetsReversed(formData?.sections)
    // Apply bottom offsets starting from second output

    remainingOutputs.forEach((output: any, index: number) => {
      const bottom = bottomOffsets[index] ?? (60 + index * 45);
      output.style.position = 'absolute';
      output.style.bottom = `${bottom}px`;
      output.style.top = 'unset';
    });
  }


  generateBottomOffsetsReversed(sections: any[]): number[] {
    const offsets: number[] = [];
    let bottom = 60;
    // Go through sections in reverse
    for (let i = sections.length - 1; i >= 0; i--) {
      const section = sections[i];

      // Go through rows in normal order inside each reversed section
      for (let j = 0; j < section.rows.length; j++) {
        offsets.push(bottom);
        bottom += 50;
      }
      if (i > 0) {
        bottom += 60; // add extra space between sections
      }
    }
    return offsets;
  }



  setOutputPositions(nodeId: any, fallbackAction: any = '') {
    const node = document.getElementById('node-' + nodeId);
    if (!node) return;
    const outputsContainer = node.querySelector('.outputs');
    const outputs: any = outputsContainer?.querySelectorAll('.output');


    if (outputs.length === 0) return;

    // Set position for output_1 (first one)
    const output1 = outputs[0];

    output1.style.position = 'absolute';
    output1.style.top = '20px'; // adjust as needed

    // Remaining outputs go from bottom up
    var remainingOutputs = Array.from(outputs).slice(1);

    if (fallbackAction == "fallback") {
      const output2 = outputs[1];
      output2.style.position = 'absolute';
      output2.style.top = '41px'; // adjust as needed
      remainingOutputs = Array.from(remainingOutputs).slice(1);

    }

    var size = 30
    remainingOutputs.forEach((output: any, index) => {
      if (output && output.style) {
        output.style.position = 'absolute';
      }
      if (output && output.style) {
        output.style.bottom = `${size}px`;
        size = size + 45
        output.style.top = 'unset';
      }
    });
  }


  createNodeHtml(nodeId: any, nodeData: any) {
    let newHTML = ``;
    const formData = nodeData.formData || {};
    const templateHead = this.ParentNodeType == 'sendMessage' ? 'Send' : this.ParentNodeType == 'questionOption' ? 'Question' : this.ParentNodeType == 'openQuestion' ? 'Open' : this.ParentNodeType == 'buttonOptions' ? 'Button' : this.ParentNodeType == 'listOptions' ? 'List' : this.ParentNodeType == 'Advance_Action' ? 'List' : 'Ask';

    const temHeaderStyle = this.ParentNodeType == 'sendMessage' ? 'background:#dadee2' :
      nodeData.text === 'questionOption' || nodeData.text === 'openQuestion' || nodeData.text == 'buttonOptions' || nodeData.text == 'listOptions' ? 'background:#fce4e4' :
        nodeData.text === 'List' ? 'background:#f93' : nodeData.category === 'Advance_Action' ? 'background:#BEDBF5' : 'background:#4bc25a';
    if (this.ParentNodeType != 'Advance_Action') {

      newHTML += `<div class="box_111" style="${temHeaderStyle}"><span class="temName">${templateHead + ' ' + this.getNodeName()}</span></div>`;

      console.log("nodeData.text", nodeData.text);
      if (this.cardType === 'sendImage' || this.cardType === 'sendVideo' || this.cardType === 'sendDocument') {
        newHTML += `<div class="textContImage">`;
        if (this.cardType === 'sendImage') {
          const imgSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
          newHTML += `<img alt="Image Preview" src="${imgSrc}" class="Preview" style="max-width: 100%;" class="mb-2" />`;
        } else if (this.cardType === 'sendVideo') {
          const videoSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
          newHTML += `<video src="${videoSrc}" class="Preview mb-2" controls style="max-width: 100%;"></video>`;
        } else if (this.cardType === 'sendDocument') {
          newHTML += `<img alt="Document Preview" src="assets/img/document.png" class="Preview" style="max-width: 100%;" class="mb-2" />`;
        }
        newHTML += `</div>`;

        if (formData.textMessage) {
          newHTML += `<div class="textCont"><p>${formData.textMessage}</p></div>`;
        }
      }
      else if (nodeData.text === 'sendText') {
        newHTML += `<div class="textCont">`;
        newHTML += `${formData.textMessage || 'Sample Text'}`;
        newHTML += `</div>`;
      }
      else if (nodeData.text === 'openQuestion') {
        newHTML += `<div class="textCont">`;
        newHTML += `${formData.questionText || 'Sample Text'}`;
        newHTML += `</div>`;
      }


      else if (nodeData.text === 'questionOption') {


        console.log("formData", formData);
        newHTML += `<div class="textQuestion">`;
        if (formData.questionText) {
          newHTML += `<h6 class="body_text">${formData.questionText}</h6>`;
        }
        newHTML += `</div>`;

        var buttonHTML: any = ``;
        if (formData?.options?.length != 0 || formData?.options != undefined) {
          formData?.options?.forEach((buttonElement: any) => {
            const uniqueId = this.generateRandom6DigitNumber();
            buttonHTML += `<button style="display:block;" class="btn btn_theme3 btn-block customButton mt-2 nodeButton-${nodeId} button_id-${uniqueId}">${buttonElement}</button>`
          });
        }

        newHTML += `<div class="buttons">${buttonHTML}</div>`;
      }

      else if (nodeData.text === 'buttonOptions') {
        newHTML += `<div class="textQuestion">`;
        if (formData.headerText) {
          newHTML += `<h6 class="body_text">${formData.headerText}</h6>`;
        }
        if (formData?.headerType === 'image' || formData?.headerType === 'video' || formData?.headerType === 'document') {
          newHTML += `<div class="textContImage">`;
          if (formData?.headerType === 'image') {
            const imgSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
            newHTML += `<img alt="Image Preview" src="${imgSrc}" class="Preview" style="max-width: 100%;" class="mb-2" />`;
          } else if (formData?.headerType === 'video') {
            const videoSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
            newHTML += `<video src="${videoSrc}" class="Preview mb-2" controls style="max-width: 100%;"></video>`;
          } else if (formData?.headerType === 'document') {
            newHTML += `<img alt="Document Preview" src="assets/img/document.png" class="Preview" style="max-width: 100%;" class="mb-2" />`;
          }
          newHTML += `</div>`;
        }
        if (formData?.bodyText) {
          newHTML += `<h6 class="body_text">${formData.bodyText || 'Sample Body Text'}</h6>`;
        }
        if (formData?.footerText) {
          newHTML += `<h6 class="body_text">${formData.footerText}</h6>`;
        }
        newHTML += `</div>`;

        var buttonHTML: any = ``;
        if (formData?.buttons?.length != 0 || formData?.buttons != undefined) {
          formData?.buttons?.forEach((buttonElement: any) => {
            const uniqueId = this.generateRandom6DigitNumber();
            buttonHTML += `<button style="display:block;" class="btn btn_theme3 btn-block customButton mt-2 nodeButton-${nodeId} button_id-${uniqueId}">${buttonElement}</button>`
          });
        }

        newHTML += `<div class="buttons">${buttonHTML}</div>`;


      }



      else if (nodeData.text === 'listOptions') {
        newHTML += `<div class="textQuestion">`;

        if (formData.headerText) {
          newHTML += `<h6 class="body_text">${formData.headerText}</h6>`;
        }


        // console.log(newHTML, "newHTML");
        if (formData.bodyText) {
          newHTML += `<h6 class="body_text">${formData.bodyText}</h6>`;
        }

        if (formData.footerText) {
          newHTML += `<h6 class="body_text">${formData.footerText}</h6>`;
        }
        newHTML += `</div>`;

        if (formData.listHeader) {
          newHTML += `<h6 class="listHeader text-center text-primary font-semibold underline my-2">${formData.listHeader}</h6>`;
        }

        // Section blocks
        if (formData?.sections?.length > 0) {
          formData.sections.forEach((section: any) => {
            newHTML += `<div class="section-card" style="background:#FFF4F2; padding: 10px; margin-bottom: 12px; border-radius: 12px;">`;

            if (section.sectionHeading) {
              newHTML += `<h6 class="section-heading font-semibold text-center mb-2" >${section.sectionHeading}</h6>`;
            }

            if (section.rows?.length > 0) {
              section.rows.forEach((row: any) => {
                const uniqueId = this.generateRandom6DigitNumber();
                newHTML += `
            <div class="option-row flex justify-between items-center bg-white p-2 rounded-md shadow-sm mb-2 nodeButton-${nodeId} button_id-${uniqueId}" style=" background: #F7F7F7 !important;border: 1px solid #d7bcbc;border-radius: 13px;">
              <span>${row.rowName}</span>
              <span class="dot bg-green-500 w-3 h-3 rounded-full"></span>
            </div>
          `;
              });
            }

            newHTML += `</div>`;
          });
        }

      }
    } else {

      newHTML += `<div class="box_111 break-text" style="${temHeaderStyle}"><span class="temName">${this.getAdvanceNodeName(this.cardType)}</span></div>`;

      if (nodeData.text == 'assignAgentModal') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Assign conversation to agent <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;"> ${formData.data.name}<span></p></div>`;
      }
      if (nodeData.text == 'assigntoContactOwner') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Conversation Assign to contact owner <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">contact owner<span></p></div>`;
      }
      if (nodeData.text == 'UnassignConversation') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>conversation will be moved to <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">Unassigned Tab<span></p></div>`;
      }
      if (nodeData.text == 'UpdateConversationStatus') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Update Conversation Status <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.status}<span></p></div>`;
      }
      if (nodeData.text == 'UpdateContactAttribute') {
        newHTML += `<div class="textCont"><p>Update Contact Attribute <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.selectedValue}<span></p></div>`;
      }
      if (nodeData.text == 'AddTags') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Add Tag <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData?.data?.tags.map((tag: any) => tag).join(',')}<span>
        </p></div>`;
      }
      if (nodeData.text == 'RemoveTag') {
        newHTML += `<div class="textCont"><p>Add Tag <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;"> ${formData?.data?.tags.map((tag: any) => tag).join(',')}<span>
       </p></div>`;
      }
      if (nodeData.text == 'TimeDelayModal') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Time Delay <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.time} ${formData.data.unit}<span></p></div>`;
      }
      if (nodeData.text == 'BotTriggerModal') {
        console.log("formData.textMessage", formData);

        newHTML += `<div class="textCont"><p>Trigger Bot <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.name} ${!formData.data.published ? '(Unpublished)' : ''}<span></p></div>`;
      }
      if (nodeData.text == 'MessageOptin') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Message Opt-in <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.status}<span></p></div>`;
      }
      if (nodeData.text == 'NotificationModal') {
        console.log("formData.textMessage", formData);
        newHTML += `<div class="textCont"><p>Notify <span style="font-size: 13px;color: #0a0a0a;font-weight: bold;">${formData.data.selectedAgentName}<span></p></div>`;
      }
    }




    newHTML += `<div class="viewSection"><img src="assets/img/edit.png" style="cursor:pointer" class="ViewNode editNode"></div>`;
    newHTML += `<div class="viewSectioncopy"><img src="assets/img/teambox/copy.svg" style="cursor:pointer" class="ViewNode copyNode"></div>`;

    return newHTML;
  }



  getAdvanceNodeName(cardType: string) {
    return this.actions.find(action => action.modal === cardType)?.label || 'Advance Action';

  }




  copyNode(nodeId: number) {
    console.log('Copying node with ID:', nodeId);
  const originalNode = this.editor.getNodeFromId(nodeId);
  if (!originalNode) return;

  // Create a deep copy of the node data
  const nodeCopy = JSON.parse(JSON.stringify(originalNode));
  console.log('Original node data:', originalNode);
  console.log('Original node data:', nodeCopy);
  
  // Generate new unique IDs for the copy
  nodeCopy.id = this.getUniqueId();
  nodeCopy.data.uniqueId = this.getUniqueId();
  
  // Offset the position so the copy doesn't overlap the original
  nodeCopy.pos_x += 100;
  nodeCopy.pos_y += 50;

  nodeCopy.inputs = {};
  nodeCopy.outputs = {};

  // Recreate inputs
  Object.keys(originalNode.inputs).forEach(inputKey => {
    nodeCopy.inputs[inputKey] = { connections: [] };
  });

  // Recreate outputs
  Object.keys(originalNode.outputs).forEach(outputKey => {
    nodeCopy.outputs[outputKey] = { connections: [] };
  });

this.cardType = nodeCopy?.data?.text; // Set the cardType to the copied node's type
this.ParentNodeType = nodeCopy?.data?.category; // Set the cardType to the copied node's type


 let  postData = {
      name: nodeCopy.name,
      inputs:  1, 
      outputs: Object.keys(nodeCopy.outputs).length,
      data: {
        text: nodeCopy?.data.text,
        inputsCount: 1,
        maxButtonLimit: 3,
        category: nodeCopy?.data.category,
        uniqueId: this.getUniqueId(),
        formData:  nodeCopy?.data?.formData,
        file: nodeCopy?.data?.formData.file,
        fileName: nodeCopy?.data?.formData.file?.name || null,
        fileType: nodeCopy?.data?.formData.file?.type || null,
      },
      html: '<div class="temp-placeholder">Loading...</div>',
      pos_x: Math.floor(Math.random() * (999 - 100 + 1)) + 100,
      pos_y: Math.floor(Math.random() * (499 - 100 + 1)) + 100,
    };

let newNodeId = this.addNode(postData);

  console.log('New node ID:', newNodeId);
  // Update the HTML and add events
  let newHTML = this.createNodeHtml(newNodeId, nodeCopy.data);
  this.updateNodeHTML(newNodeId, newHTML);

  console.log('Node copied with new ID:', nodeId);
  
    if (nodeCopy?.data?.text == 'listOptions') {
      this.setOutputPositionsforlist(newNodeId, nodeCopy?.data?.formData);
    } else {
      this.setOutputPositions(Number(newNodeId), nodeCopy?.data?.formData?.invalidAction);
    }
  
  this.nodeCounter++;
}


  updateNodeHTML(nodeId: number, newHTML: string) {
    const node = this.editor.getNodeFromId(nodeId);
    if (node) {
      node.html = newHTML;
      const nodeElement = document.querySelector(`#node-${nodeId} .drawflow_content_node`);
      if (nodeElement) {
        // Store the current scroll position
        const scrollTop = nodeElement.scrollTop;
        const scrollLeft = nodeElement.scrollLeft;
        // Update the HTML
        nodeElement.innerHTML = newHTML;
        // Reattach event listeners
        this.addNodeEvent(nodeId);

        // Restore scroll position
        nodeElement.scrollTop = scrollTop;
        nodeElement.scrollLeft = scrollLeft;
      }
    }
  }

  getNodeName(): string {
    console.log('Getting node name for card type:', this.cardType);
    switch (this.cardType) {
      case 'sendText': return 'Message';
      case 'sendImage': return 'Image';
      case 'sendVideo': return 'Video';
      case 'sendDocument': return 'Document';
      case 'questionOption': return 'Options';
      case 'openQuestion': return 'Question';
      case 'buttonOptions': return 'Options';
      case 'listOptions': return 'Options';
      default: return 'Node';
    }
  }

  addNode(postData: any) {
    console.log('Adding node with data:', postData);
    return this.editor.addNode(
      postData.name,
      postData.inputs,
      postData.outputs,
      postData.pos_x,
      postData.pos_y,
      postData.name,
      postData.data,
      postData.html
    );
  }




  addNodeEvent(nodeId: number) {
    // Use setTimeout to ensure the DOM is fully updated
    setTimeout(() => {
      const nodeElement = document.querySelector(`#node-${nodeId}`);
      if (!nodeElement) return;

      const editNodeIconClick = nodeElement.querySelector('.editNode');
      if (editNodeIconClick) {
        editNodeIconClick.removeEventListener('click', this.handleEditClick);
        this.handleEditClick = (event: Event) => {
          event.stopPropagation();
          this.openEditModal(nodeId);

        };
        editNodeIconClick.addEventListener('click', this.handleEditClick);
      }
      const copyNodeIconClick = nodeElement.querySelector('.copyNode');
      if (copyNodeIconClick) {
        copyNodeIconClick.removeEventListener('click', this.handleCopyClick);
        this.handleCopyClick = (event: Event) => {
          event.stopPropagation();
          this.copyNode(nodeId)
        };

        copyNodeIconClick.addEventListener('click', this.handleCopyClick);
      }
    }, 0);
  }


  updateExistingNode(formData: any) {
    if (this.selectedNodeId === null) return;

    var form = formData
    const node = this.editor.getNodeFromId(this.selectedNodeId);
    node.data.formData = formData;

    if (this.cardType === 'sendImage' || this.cardType === 'sendVideo' || this.cardType === 'sendDocument') {
      node.data.file = formData.file;
    }

    const currentOutputsCount = Object.keys(node.outputs).length;
    var newOutputsCount
    if (this.cardType === 'listOptions') {
      const sectionRows = formData?.sections?.reduce((acc: any, section: any) => acc + (section.rows?.length || 0), 0) || 0;
      newOutputsCount = this.cardType === 'listOptions'
        ? (sectionRows + 1 || 1)
        : currentOutputsCount;
    } else if (this.cardType === 'questionOption') {

      newOutputsCount = this.cardType === 'questionOption'
        ? (formData?.options?.length + 1 || 1)
        : currentOutputsCount;
    } else if (this.cardType === 'buttonOptions') {
      newOutputsCount = this.cardType === 'buttonOptions'
        ? (formData?.buttons?.length + 1 || 1) : currentOutputsCount;
    }


    if ((this.cardType === 'questionOption' || this.cardType === 'listOptions' || this.cardType === 'buttonOptions') && newOutputsCount !== currentOutputsCount) {
      this.updateNodeOutputs(node, currentOutputsCount, newOutputsCount, formData);
    }
    this.editor.updateNodeDataFromId(this.selectedNodeId, node.data);

    let newHTML = this.createNodeHtml(this.selectedNodeId, node.data);
    this.updateNodeHTML(this.selectedNodeId, newHTML);

  }

  updateNodeOutputs(node: any, currentOutputsCount: number, newOutputsCount: number, formData: any) {

    console.log(currentOutputsCount, node.id, this.editor.getNodeFromId(node.id));

    while (currentOutputsCount > 1) {
      currentOutputsCount = currentOutputsCount - 1
      this.editor.removeNodeOutput(Number(node.id), 'output_' + (currentOutputsCount));
    }
    for (let i = 1; i < newOutputsCount; i++) {
      this.editor.addNodeOutput(node.id);
    }
    // Update the node's outputs property
    node.outputs = newOutputsCount;
    if (this.ParentNodeType == 'listOptions') {
      this.setOutputPositionsforlist(node.id, formData);
    } else {
      this.setOutputPositions(node.id);
    }

  }
  // rendom number for button
  generateRandom6DigitNumber() {
    return Math.floor(100000 + Math.random() * 900000);
  }



  // Add these class properties to store the bound functions
  handleEditClick: (event: Event) => void = () => { };
  handleCopyClick: (event: Event) => void = () => { };

  openEditModal(nodeId: number) {
    // Close any existing modal first
    this.closeModal();
    this.isEditMode = true;
    this.selectedNodeId = nodeId;
    const nodeData = this.editor.getNodeFromId(nodeId);
    this.cardType = nodeData.data.text;
    this.ParentNodeType = nodeData.data.category

    this.fillExistData();
    const modalToOpen = this.ParentNodeType
    this.openModal(modalToOpen);

  }


  fillExistData() {
    if (this.selectedNodeId === null) return;
    this.selectedImageUrl = null;
    const nodeElement: any = document.getElementById(`node-${this.selectedNodeId}`);
    const nodeData = this.editor.getNodeFromId(this.selectedNodeId);

    console.log('Filling existing data for node:', this.selectedNodeId, 'Data:', nodeData);
    if (this.cardType === 'sendText') {
      this.sendTextForm.patchValue({
        textMessage: nodeData.data.formData.textMessage === 'Sample Text' ? '' : nodeData.data.formData.textMessage,
        file: null
      });
    }
    else if (this.cardType === 'sendImage' || this.cardType === 'sendVideo' || this.cardType === 'sendDocument') {
      this.selectedFileType = this.cardType === 'sendImage' || this.cardType === 'sendDocument' ? 'image' : 'video';
      console.log('selectedFileType', this.selectedFileType);

      const imgElement = nodeElement.querySelector('.textContImage img, .textContImage video');
      console.log('selectedFileType', imgElement);
      if (imgElement) {
        this.selectedImageUrl = imgElement.src;
      }
      this.sendTextForm.patchValue({
        textMessage: nodeData.data.formData.textMessage || '',
        file: nodeData.data.file
      });
    }
    else if (this.cardType === 'Question') {
      const header = nodeElement.querySelector('.header_text')?.textContent;
      const body = nodeElement.querySelector('.body_text')?.textContent;
      const footer = nodeElement.querySelector('.footer_text')?.textContent;
      const buttons = nodeElement.querySelectorAll('.buttons button');

      this.questionOption.patchValue({
        header: header === 'Sample Header Text' ? '' : header,
        bodyText: body === 'Sample Body Text' ? '' : body,
        footerText: footer || '',
        button1: buttons[0]?.textContent.trim() || '',
        button2: buttons[1]?.textContent.trim() || ''
      });
    }

    else if (this.cardType === 'questionOption') {
      const updateForm = nodeData?.data?.formData;

      // Clear and set FormArray manually
      const optionsArray = this.fb.array([]);
      if (Array.isArray(updateForm?.options)) {
        updateForm.options.forEach((opt: any) => {
          optionsArray.push(this.fb.control(opt));
        });
      }

      // Now patch the rest of the form
      this.questionOption.patchValue({
        questionText: updateForm?.questionText,
        saveAnswerVariable: updateForm?.saveAnswerVariable,
        reattemptsAllowed: updateForm?.reattemptsAllowed,
        reattemptsCount: updateForm?.reattemptsCount,
        errorMessage: updateForm?.errorMessage,
        invalidAction: updateForm?.invalidAction,
        enableTimeElapse: updateForm?.enableTimeElapse,
        timeElapseMinutes: updateForm?.timeElapseMinutes,
        timeElapseAction: updateForm?.timeElapseAction,
        saveAsVariable: updateForm?.saveAsVariable,
        variableName: updateForm?.variableName,
        variableDataType: updateForm?.variableDataType,
        enableValidation: updateForm?.enableValidation
      });

      // Replace the old options array with the new one
      this.questionOption.setControl('options', optionsArray);
    }

    else if (this.cardType === 'openQuestion') {
      const updateForm = nodeData?.data?.formData;

      this.openQuestion.patchValue({
        questionText: updateForm?.questionText,
        saveAsVariable: updateForm?.saveAsVariable,
        variableName: updateForm?.variableName,
        variableDataType: updateForm?.variableDataType,
        enableValidation: updateForm?.enableValidation,
        answerType: updateForm?.answerType,

        // Text validation
        minChars: updateForm?.minChars ?? 0,
        maxChars: updateForm?.maxChars ?? null,
        textRegex: updateForm?.textRegex ?? '',

        // Number validation
        minNumber: updateForm?.minNumber ?? null,
        maxNumber: updateForm?.maxNumber ?? null,
        numberRegex: updateForm?.numberRegex ?? '',

        // Date validation
        minDate: updateForm?.minDate ?? null,
        maxDate: updateForm?.maxDate ?? null,

        // Custom validation
        customRegex: updateForm?.customRegex ?? '',

        // Reattempts
        reattemptsAllowed: updateForm?.reattemptsAllowed,
        reattemptsCount: updateForm?.reattemptsCount ?? 1,
        errorMessage: updateForm?.errorMessage,
        invalidAction: updateForm?.invalidAction,

        // Time elapse
        enableTimeElapse: updateForm?.enableTimeElapse,
        timeElapseMinutes: updateForm?.timeElapseMinutes,
        timeElapseAction: updateForm?.timeElapseAction
      });
    }
    else if (this.cardType === 'buttonOptions') {
      const updateForm = nodeData?.data?.formData;

      this.buttonOptions.patchValue({
        headerType: updateForm?.headerType,
        headerText: updateForm?.headerText,
        bodyText: updateForm?.bodyText,
        footerText: updateForm?.footerText,
        fileLink: updateForm?.fileLink,
        saveAsVariable: updateForm?.saveAsVariable,
        variableName: updateForm?.variableName,
        variableDataType: updateForm?.variableDataType,
        reattemptsAllowed: updateForm?.reattemptsAllowed,
        reattemptsCount: updateForm?.reattemptsCount ?? 1,
        errorMessage: updateForm?.errorMessage,
        invalidAction: updateForm?.invalidAction,
        enableTimeElapse: updateForm?.enableTimeElapse,
        timeElapseMinutes: updateForm?.timeElapseMinutes,
        timeElapseAction: updateForm?.timeElapseAction,
        enableValidation: updateForm?.enableValidation
      });

      // Replace buttons FormArray
      const buttonsArray = this.fb.array([]);
      (updateForm?.buttons || []).forEach((btn: string) => {
        buttonsArray.push(this.fb.control(btn, [Validators.required, Validators.maxLength(20)]));
      });

      this.buttonOptions.setControl('buttons', buttonsArray);
    }

  }








  getUniqueId() {
    return `id-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }







  onTextChange() {
    this.sendTextForm.get('textMessage')?.updateValueAndValidity({ emitEvent: true });
  }


  onFileSelected(event: Event) {
    const fileInput = event.target as HTMLInputElement;
    const file = fileInput.files?.[0];
    if (!file) return;

    this.uploadedFile = file;
    this.sendTextForm.patchValue({ file: file });
    this.selectedFileType = this.buttonOptions.get('headerType')?.value as 'image' | 'video' | 'document';

    const reader = new FileReader();
    reader.onload = () => {
      this.selectedFileUrl = reader.result as string;
    };
    reader.readAsDataURL(file);
  }



  getFileAccept(): string {
    switch (this.cardType) {
      case 'sendImage': return 'image/*';
      case 'sendVideo': return 'video/mp4';
      case 'sendDocument': return '.pdf,.doc,.docx,.xls,.xlsx';
      default: return '*';
    }
  }



  handleQuestionSubmit(FormType: any = '') {
    var formData
    if (FormType === 'questionOption') {
      if (this.questionOption.invalid) {
        this.questionOption.markAllAsTouched();
        return;
      }
      formData = this.questionOption.value;
    } else if (FormType === 'openQuestion') {
      if (this.openQuestion.invalid) {
        this.openQuestion.markAllAsTouched();
        return;
      }
      formData = this.openQuestion.value;
    }
    else if (FormType === 'buttonOptions') {
      if (this.buttonOptions.invalid) {
        this.buttonOptions.markAllAsTouched();
        return;
      }
      formData = this.buttonOptions.value;
    }
    else if (FormType === 'listOptions') {
      if (this.listOptions.invalid) {
        this.listOptions.markAllAsTouched();
        return;
      }
      formData = this.listOptions.value;
    }
    this.closeModal()

    if (this.isEditMode && this.selectedNodeId !== null) {
      this.updateExistingNode(formData);
    } else {
      this.createNewNodeWithData(formData);
    }
    // this.currentModalRef?.close();
  }


  advanceOptionsSubmit(FormType: any = '') {
    this.closeModal()


    var advanceOption = { type: FormType, data: {} };
    if (FormType === 'assignAgentModal') {
      advanceOption.data = this.selectedAgentDetails
    }

    var tags = {}

    if (FormType == 'UpdateConversationStatus') {
      advanceOption.data = this.conversationActions
    }
    if (FormType == 'UpdateContactAttribute') {
      advanceOption.data = this.contactAttributeForm.value
    }
    if (FormType == 'NotificationModal') {
      advanceOption.data = this.notificationForm.value
    }
    if (FormType == 'MessageOptin') {
      advanceOption.data = this.conversationActions
    }
    if (FormType == 'TimeDelayModal') {
      var TimeDelay = { time: this.delayTime, unit: this.delayUnit }
      advanceOption.data = TimeDelay
    }

    if (FormType == 'BotTriggerModal') {
      console.log("this.selectedBot", this.selectedBot);
      advanceOption.data = this.selectedBot
    }
    if (FormType == 'AddTags') {
      tags = { tags: this.selectedTags, operation: this.operationOptions }
      advanceOption.data = tags
    } if (FormType == 'RemoveTag') {
      tags = { tags: this.selectedTags, operation: this.operationOptions }
      advanceOption.data = tags
    }



    if (this.isEditMode && this.selectedNodeId !== null) {
      // this.updateExistingNode(formData);
    } else {

      this.createNewNodeWithData(advanceOption);
    }

  }




  openModal(modalId: string): void {
    if (this.currentModal) {
      this.currentModal.hide();
    }

    const modalElement = document.getElementById(modalId);
    if (modalElement) {
      // Initialize the modal if it hasn't been initialized yet
      if (!modalElement.classList.contains('show')) {
        this.currentModal = new bootstrap.Modal(modalElement);
      }
      this.currentModal.show();
      modalElement.addEventListener('hidden.bs.modal', () => {
        this.currentModal = null;
      });
    } else {
      console.warn(`Modal with ID '${modalId}' not found.`);
    }
  }

  closeModal(): void {
    $('#myModal').modal('content');
    if (this.currentModal) {
      this.currentModal.hide();
      this.currentModal = null;
    }
  }












  onAgentChange(event: any) {
    const agentId = event.target.value;
    const selectedAgent = this.availableAgents.find(agent => agent.id == agentId);
    console.log('Selected agent:', selectedAgent);
    this.notificationForm.patchValue({
      selectedAgentName: selectedAgent?.name || ''
    });
  }



  initForms() {
    this.sendTextForm = this.fb.group({
      textMessage: [''],
      file: [null]
    });

    this.sendTextForm.get('textMessage')?.valueChanges.subscribe(val => {
      this.characterCount = val?.length || 0;
    });

    this.questionOption = this.createQuestionForm();
    this.buttonOptions = this.createButtonsForm();

    this.listOptions = this.fb.group({
      headerText: ['', [Validators.maxLength(60)]],
      bodyText: ['', [Validators.required, Validators.maxLength(1024)]],
      footerText: ['', [Validators.maxLength(60)]],
      listHeader: ['', [Validators.maxLength(20)]],
      sections: this.fb.array([this.createSection()]),
      saveAsVariable: [false],
      variableName: [''],
      variableDataType: ['text'],
      reattemptsAllowed: [false],
      reattemptsCount: [1],
      errorMessage: ['', [Validators.maxLength(1024)]],
      invalidAction: ['skip'],
      enableTimeElapse: [false],
      timeElapseMinutes: [''],
      timeElapseAction: ['skip'],
      enableValidation: [false]
    });



    this.openQuestion = this.fb.group({
      questionText: ['', [Validators.required, Validators.maxLength(1024)]],
      saveAsVariable: [false],
      variableName: ['', [this.validateVariableName.bind(this)]],
      variableDataType: ['text'],
      enableValidation: [false],
      answerType: ['text'],
      // Text validation
      minChars: [0, Validators.min(0)],
      maxChars: [null, Validators.min(1)],
      textRegex: [''],
      // Number validation
      minNumber: [null],
      maxNumber: [null],
      numberRegex: [''],
      // Date validation
      minDate: [null],
      maxDate: [null],
      // Custom validation
      customRegex: [''],
      // Reattempts
      reattemptsAllowed: [false],
      reattemptsCount: [1, [Validators.min(1)]],
      errorMessage: [''],
      invalidAction: ['skip'],
      // Time elapse
      enableTimeElapse: [false],
      timeElapseMinutes: ['', [Validators.min(1)]],
      timeElapseAction: ['skip']
    });

    this.conditionForm = this.fb.group({
      conditions: this.fb.array([])
    });

    this.contactAttributeForm = this.fb.group({
      selectedAttribute: [null, Validators.required],
      selectedValue: [''],
      inputValue: [''],
      selectedVariable: [''],
      operation: ['replace', Validators.required],
      askQuestion: [false]
    });
    this.addCondition();
    this.setupFormListeners(this.questionOption);
    this.setupFormListeners(this.buttonOptions);
    this.setupFormListeners(this.openQuestion);
    this.setupFormListeners(this.listOptions);

    this.notificationForm = this.fb.group({
      selectedAgentIds: [[], Validators.required],
      selectedAgentName: [''],
      textMessage: ['', [Validators.required, Validators.maxLength(1024)]]
    });

    this.notificationForm.get('textMessage')?.valueChanges.subscribe(val => {
      this.characterCount = val?.length || 0;
    });

  }


  isOpen = {
    send: false,
    ask: false,
    condition: false
  };

  toggle(section: 'send' | 'ask' | 'condition') {
    this.isOpen[section] = !this.isOpen[section];
  }

  allowDrop(event: DragEvent): void {
    event.preventDefault();
  }

  drop(event: DragEvent): void {
    event.preventDefault();
    const nodeType = event.dataTransfer?.getData('nodeType');
    if (nodeType) {
      // this.createNewNode(nodeType);
    }
  }



  markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      } else if (control instanceof FormArray) {
        control.controls.forEach(arrayControl => {
          if (arrayControl instanceof FormGroup) {
            this.markFormGroupTouched(arrayControl);
          } else {
            arrayControl.markAsTouched();
          }
        });
      }
    });
  }

  validateVariableName(control: import('@angular/forms').AbstractControl) {
    const value = control.value;
    if (!value) return null;

    if (!/^[a-zA-Z]/.test(value)) {
      return { invalidStart: true };
    }

    if (!/^[a-zA-Z0-9_]+$/.test(value)) {
      return { invalidChars: true };
    }

    return null;
  }

  // ==================== FORM SETUP METHODS ====================

  setupFormListeners(form: FormGroup) {
    // Reattempts validation
    form.get('reattemptsAllowed')?.valueChanges.subscribe(value => {
      const errorMessageControl = form.get('errorMessage');
      if (value) {
        errorMessageControl?.setValidators([Validators.required, Validators.maxLength(1024)]);
      } else {
        errorMessageControl?.clearValidators();
        errorMessageControl?.setValidators([Validators.maxLength(1024)]);
      }
      errorMessageControl?.updateValueAndValidity();
    });

    // Time elapse validation
    form.get('enableTimeElapse')?.valueChanges.subscribe(value => {
      const minutesControl = form.get('timeElapseMinutes');
      if (value) {
        minutesControl?.setValidators([Validators.required, Validators.min(1)]);
      } else {
        minutesControl?.clearValidators();
      }
      minutesControl?.updateValueAndValidity();
    });

    // Variable name validation when checkbox changes
    form.get('saveAsVariable')?.valueChanges.subscribe(value => {
      const variableNameControl = form.get('variableName');
      if (value) {
        variableNameControl?.setValidators([Validators.required, this.validateVariableName.bind(this)]);
      } else {
        variableNameControl?.clearValidators();
      }
      variableNameControl?.updateValueAndValidity();
    });
  }

  // ==================== QUESTION MODAL METHODS ====================

  createQuestionForm() {
    return this.fb.group({
      questionText: ['', [Validators.required, Validators.maxLength(4056)]],
      options: this.fb.array(['']),
      saveAnswerVariable: [''],
      reattemptsAllowed: [false],
      reattemptsCount: [1],
      errorMessage: ['', [Validators.maxLength(1024)]],
      invalidAction: ['skip'],
      enableTimeElapse: [false],
      timeElapseMinutes: [''],
      timeElapseAction: ['skip'],
      saveAsVariable: [false],
      variableName: [''],
      variableDataType: ['text'],
      enableValidation: [false]
    });
  }

  addOption(options: FormArray) {
    const lastOption = options.at(options.length - 1).value;

    if ((!lastOption || lastOption.trim() === '') && options.length > 1) {
      this.newOptionError = 'Please fill the previous option before adding a new one.';
      return;
    }

    if (options.length >= this.MAX_OPTIONS) {
      this.newOptionError = `Maximum of ${this.MAX_OPTIONS} options allowed.`;
      return;
    }

    options.push(this.fb.control(''));
    this.newOptionError = '';
  }

  removeOption(options: FormArray, index: number) {
    options.removeAt(index);
  }

  // ==================== BUTTONS MODAL METHODS ====================

  createButtonsForm() {
    return this.fb.group({
      headerType: ['none'],
      headerText: ['', [Validators.maxLength(60)]],
      bodyText: ['', [Validators.required, Validators.maxLength(1024)]],
      footerText: ['', [Validators.maxLength(60)]],
      buttons: this.fb.array([this.fb.control('', [Validators.required, Validators.maxLength(20)])]),
      fileLink: [''],
      saveAsVariable: [false],
      variableName: [''],
      variableDataType: ['text'],
      reattemptsAllowed: [false],
      reattemptsCount: [1],
      errorMessage: ['', [Validators.maxLength(1024)]],
      invalidAction: ['skip'],
      enableTimeElapse: [false],
      timeElapseMinutes: [''],
      timeElapseAction: ['skip'],
      enableValidation: [false]
    });
  }

  addButton(buttons: FormArray) {
    if (buttons.length < this.MAX_BUTTONS) {
      buttons.push(this.fb.control('', [Validators.required, Validators.maxLength(20)]));
    }
  }

  removeButton(buttons: FormArray, index: number) {
    if (buttons.length > 1) {
      buttons.removeAt(index);
    }
  }


  get buttons() {
    return this.buttonOptions.get('buttons') as FormArray;
  }
  getFileAcceptType(headerType: string): string {
    switch (headerType) {
      case 'image': return 'image/*';
      case 'video': return 'video/*';
      case 'document': return '.pdf,.doc,.docx,.txt';
      default: return '';
    }
  }

  onFileSelectedData(event: any) {

    const file = event.target.files[0];
    const input = event.target as HTMLInputElement;
    if (file) {
      const mimeType = file.type;

      let headerType: 'image' | 'video' | 'document' | 'unknown' = 'unknown';

      if (mimeType.startsWith('image/')) {
        headerType = 'image';
      } else if (mimeType.startsWith('video/')) {
        headerType = 'video';
      } else if (
        mimeType === 'application/pdf' ||
        mimeType === 'application/msword' ||
        mimeType.includes('spreadsheet') || // for Excel
        mimeType.includes('document')
      ) {
        headerType = 'document';
      }
      const maxSize = headerType === 'image' ? 5 * 1024 * 1024 : 10 * 1024 * 1024;

      if (file.size > maxSize) {
        alert(`File size exceeds maximum allowed (${headerType === 'image' ? '5MB' : '10MB'})`);
        return;
      }

      this.sendTextForm.patchValue({ file: file });
      console.log('Selected file:', file);
      this.uploadedFile = file;
      this.selectedFileType = headerType;
      this.selectedFileUrl = URL.createObjectURL(file);

      console.log('Selected file URL:', this.selectedFileType);
      if (headerType === 'image') {
        this.selectedImageUrl = this.selectedFileUrl;
      } else if (headerType === 'document') {
        this.selectedImageUrl = 'assets/img/document.png'; // Placeholder for document preview
      } else if (headerType === 'video') {
        this.selectedImageUrl = this.selectedFileUrl; // Placeholder for video preview
      }
    }
    input.value = '';

    console.log('File selected:', this.selectedImageUrl);
  }

  removeFile() {
    this.selectedFileUrl = null;
    this.uploadedFile = null;
    this.selectedFileType = null;
    this.selectedImageUrl = null;
    const fileInput = document.querySelector('input[type="file"]') as HTMLInputElement;
    if (fileInput) {
      fileInput.value = '';
    }
  }

  // ==================== LIST MODAL METHODS ====================



  createSection() {
    return this.fb.group({
      sectionHeading: ['', [Validators.maxLength(24)]],
      rows: this.fb.array([this.createRow()])
    });
  }

  createRow() {
    return this.fb.group({
      rowName: ['', [Validators.required, Validators.maxLength(24)]],
      rowDescription: ['', [Validators.maxLength(72)]]
    });
  }

  addSection(sections: FormArray) {
    if (sections.length < this.MAX_SECTIONS) {
      sections.push(this.createSection());
    }
  }

  removeSection(sections: FormArray, index: number) {
    if (sections.length > 1) {
      sections.removeAt(index);
    }
  }

  addRow(sections: FormArray, sectionIndex: number) {
    const section = sections.at(sectionIndex) as FormGroup;
    const rows = section.get('rows') as FormArray;

    if (this.getTotalRowCount(sections) < (this.MAX_SECTIONS * this.MAX_ROWS_PER_SECTION)) {
      rows.push(this.createRow());
    }
  }

  removeRow(sections: FormArray, sectionIndex: number, rowIndex: number) {
    const section = sections.at(sectionIndex) as FormGroup;
    const rows = section.get('rows') as FormArray;

    if (rows.length > 1) {
      rows.removeAt(rowIndex);
    }
  }

  getTotalRowCount(sections: FormArray): number {
    let total = 0;
    sections.controls.forEach(section => {
      const rows = (section as FormGroup).get('rows') as FormArray;
      total += rows.length;
    });
    return total;
  }

  // ==================== EDITOR METHODS ====================

  updateQuestionTextLength(editor: RichTextEditor) {
    const text = editor.getHtml();
    this.questionTextLength = text ? text.length : 0;
  }

  updateBodyTextLength(editor: RichTextEditor) {
    const text = editor.getHtml();
    this.bodyTextLength = text ? text.length : 0;
  }

  updateErrorMessageLength(editor: RichTextEditor) {
    const text = editor.getHtml();
    this.errorMessageLength = text ? text.length : 0;
  }

  updateHeaderTextLength(control: FormGroup) {
    this.headerTextLength = control.value?.length || 0;
  }

  updateFooterTextLength(control: FormGroup) {
    this.footerTextLength = control.value?.length || 0;
  }

  updateListHeaderLength(control: FormGroup) {
    this.listHeaderLength = control.value?.length || 0;
  }








  getSectionRows(sections: FormArray, sectionIndex: number): FormArray {
    const section = sections.at(sectionIndex) as FormGroup;
    return section.get('rows') as FormArray;
  }

  getSectionHeadingLength(sections: FormArray, sectionIndex: number): number {
    const section = sections.at(sectionIndex) as FormGroup;
    return section.get('sectionHeading')?.value?.length || 0;  // Updated to 'sectionHeading'
  }

  getRowNameLength(sections: FormArray, sectionIndex: number, rowIndex: number): number {
    const rows = this.getSectionRows(sections, sectionIndex);
    const row = rows.at(rowIndex) as FormGroup;
    return row.get('rowName')?.value?.length || 0;  // Updated to 'rowName'
  }

  getRowDescriptionLength(sections: FormArray, sectionIndex: number, rowIndex: number): number {
    const rows = this.getSectionRows(sections, sectionIndex);
    const row = rows.at(rowIndex) as FormGroup;
    return row.get('rowDescription')?.value?.length || 0;  // Updated to 'rowDescription'
  }


  // ==================== EVENT HANDLERS ====================

  onReattemptsChange(event: any, form: FormGroup) {
    if (event.target.checked) {
      form.get('reattemptsCount')?.setValue(1);
    }
  }

  onTimeElapseChange(event: any, form: FormGroup) {
    if (event.target.checked) {
      form.get('timeElapseAction')?.setValue('skip');
    }
  }

  onSaveAsVariableChange(event: any, form: FormGroup) {
    if (event.target.checked) {
      form.get('variableName')?.setValue('');
      form.get('variableDataType')?.setValue('text');
    }
  }

  onValidationToggle(form: FormGroup) {
    if (!form.get('enableValidation')?.value) {
      // Reset validation fields when toggled off
      form.patchValue({
        reattemptsAllowed: false,
        enableTimeElapse: false,
        invalidAction: 'skip'
      });
    }
  }

  onHeaderTypeChange(form: FormGroup) {
    if (form.get('headerType')?.value === 'none') {
      this.removeFile();
    }
  }








  get options() {
    return this.questionOption.get('options') as FormArray;
  }

  get sections() {
    return this.buttonOptions.get('sections') as FormArray;
  }
  get listOptionSections() {
    return this.listOptions.get('sections') as FormArray ?? this.fb.array([]);
  }

  onAnswerTypeChange() {
    // Reset validation fields when answer type changes
    const answerType = this.openQuestion.get('answerType')?.value;
    const resetValues = {
      minChars: 0,
      maxChars: null,
      textRegex: '',
      minNumber: null,
      maxNumber: null,
      numberRegex: '',
      minDate: null,
      maxDate: null,
      customRegex: ''
    };
    this.openQuestion.patchValue(resetValues);
  }



  onSubmits(form: FormGroup) {
    if (form.valid) {
      console.log('Form submitted:', form.value);
      // Handle form submission
      this.closeModal()
      return true;
    } else {
      this.markFormGroupTouched(form);
      return false;
    }
  }

































  // get conditions(): FormArray {
  //   return this.conditionsForm.get('conditions') as FormArray;
  // }

  get conditionsArray(): FormArray {
    return this.conditionForm.get('conditions') as FormArray;
  }

  getConditionGroup(index: number): FormGroup {
    return this.conditionsArray.at(index) as FormGroup;
  }


  addCondition(condition?: any): void {
    const conditionGroup = this.fb.group({
      comparator: [condition?.comparator || '', Validators.required],
      comparatorType: [condition?.comparatorType || ''],
      operator: [condition?.operator || '', Validators.required],
      value: [condition?.value || '', Validators.required],
      valueType: [condition?.valueType || ''],
      nextJoinType: [condition?.nextJoinType || 'AND']
    });

    this.conditionsArray.push(conditionGroup);
  }

  removeCondition(index: number): void {
    this.conditionsArray.removeAt(index);
  }



  getOperators(type: string): string[] {
    if (type === 'string') return this.stringOperators;
    if (type === 'number') return this.numberOperators;
    if (type === 'boolean') return this.booleanOperators;
    return [];
  }

  toggleVarMenu(index: number, field: 'comparator' | 'value'): void {
    if (this.showVarMenuFor?.index === index && this.showVarMenuFor?.field === field) {
      this.showVarMenuFor = null;
    } else {
      this.showVarMenuFor = { index, field };
    }
  }

  selectVariable(index: number, field: 'comparator' | 'value', variable: any): void {
    const group = this.getConditionGroup(index);
    group.get(field)?.setValue(`{{${variable.name}}}`);
    group.get(`${field}Type`)?.setValue(variable.type);
    this.showVarMenuFor = null;

    // Reset operator if comparator changed
    if (field === 'comparator') {
      group.get('operator')?.setValue('');
    }
  }

  saveConditions(): void {

    const isMet = this.evaluateConditions();

    if (isMet) {
      console.log(' Condition Met  follow green path');
      // this.navigateToNode('condition_met');
    } else {
      console.log(' Condition Not Met  follow red path');
      // this.navigateToNode('condition_not_met');
    }

    this.closeModal();

    if (this.conditionForm.valid) {
      this.conditions = this.conditionsArray.value;
      console.log('Conditions saved:', this.conditions);
      // this.conditionsChange.emit(this.conditions);

    }
  }

  onComparatorChange(index: number) {
    const comparatorControl = this.getConditionGroup(index).get('comparator');
    const comparatorValue = comparatorControl?.value;

    const detectedType = this.detectVariableType(comparatorValue);
    this.getConditionGroup(index).get('comparatorType')?.setValue(detectedType);

    // Optional: reset operator field when type changes
    this.getConditionGroup(index).get('operator')?.reset();
  }


  detectVariableType(comparator: string): string {
    // Check in attributeList
    const attribute = this.attributeList.find(attr => attr.value === comparator || attr.label === comparator);
    if (attribute) {
      return attribute.type;
    }

    // Check in sampleVariables (bot vars)
    const botVar = this.sampleVariables.find((v: any) => v.value === comparator || v.label === comparator);
    if (botVar) {
      return botVar.type;
    }

    // Default fallback
    return 'string';
  }


  evaluateConditions(): boolean {
    const conditions: any = this.conditionsArray.controls;
    let result = this.evaluateSingleCondition(conditions[0]);

    for (let i = 1; i < conditions.length; i++) {
      const group = conditions[i] as FormGroup;
      const join = conditions[i - 1].get('nextJoinType')?.value;

      const current = this.evaluateSingleCondition(group);

      if (join === 'AND') {
        result = result && current;
      } else if (join === 'OR') {
        result = result || current;
      }
    }

    return result;
  }

  evaluateSingleCondition(group: FormGroup): boolean {
    const comparator = group.get('comparator')?.value;
    const operator = group.get('operator')?.value;
    const value = group.get('value')?.value;
    const dataType = group.get('dataType')?.value;

    const actualValue = this.resolveVariable(comparator); // fetch real value from store/variable list

    switch (operator) {
      case '=':
        return actualValue == value;
      case '!=':
        return actualValue != value;
      case '>':
        return Number(actualValue) > Number(value);
      case '<':
        return Number(actualValue) < Number(value);
      case 'contains':
        return actualValue.includes(value);
      case 'does not contain':
        return !actualValue.includes(value);
      case 'starts with':
        return actualValue.startsWith(value);
      case 'ends with':
        return actualValue.endsWith(value);
      case 'is true':
        return actualValue === true;
      case 'is false':
        return actualValue === false;
      default:
        return false;
    }
  }

  resolveVariable(key: string): any {
    // You should replace this with your actual variable resolution logic
    return this.sampleVariables.find((v: any) => v.key === key)?.value || '';
  }







  activeSidebar: 'main' | 'advance' = 'main';

  openSidebar(type: 'main' | 'advance') {
    this.activeSidebar = type;
  }

  selectedAdvanceAction: any = null;
  onActionClick(action: any) {
    console.log('Action clicked:', action);
    console.log('Action data:', action.modal);
    this.selectedAdvanceAction = action;
    this.openModal(action.modal);
    // Handle action click logic here
  }







  filterAgents() {
    console.log('Filtering agents with query:', this.searchQuery);
    if (!this.searchQuery) {
      this.filteredAgents = [...this.agents];
      return;
    }
    this.filteredAgents = this.agents.filter(agent =>
      agent.name.toLowerCase().includes(this.searchQuery.toLowerCase())
    );
  }

  selectAgent(agent: any) {
    this.selectedAgentDetails = agent;
  }

  getInitials(name: string): string {
    return name.split(' ').map(part => part[0]).join('');
  }

  onCancel() {
    // this.cancel.emit();
    this.closeModal()
  }

  onSave() {
    if (this.selectedAgentDetails) {

      console.log(this.selectedAgentDetails)


      // createCardForAgent()
      this.closeModal()
    }
  }


openDropdown = {status:''}
  selectAttribute(status:any){
    this.openDropdown.status =  status

  }

  selectedValues(variable: any) {
    console.log('Selected variable:', variable);
      this.contactAttributeForm.patchValue({
      selectedValue: `{{${variable?.name}}} ` || '',
      inputValue:'',
      selectedVariable: '',
      operation: 'replace'
    });
    this.openDropdown.status = ''
     this.contactAttributeForm.get('selectedValue')?.updateValueAndValidity();
  }


  onAttributeChange(value: string) {
    
    const selectedAttr = this.contactAttributeForm.get('selectedAttribute')?.value;
    this.attributeDetails = this.availableAttributes.find(attr => attr.name === selectedAttr);


  }

 

  // onCancel() {
  //   // Handle cancel logic
  //   this.contactAttributeForm.reset({
  //     operation: 'replace'
  //   });
  // }







  filteredTags: any[] = [...this.allTags];

  filterTags(): void {
    if (!this.searchTerm) {
      this.filteredTags = [...this.allTags];
      return;
    }

    this.filteredTags = this.allTags.filter(tag =>
      tag.label.toLowerCase().includes(this.searchTerm.toLowerCase())
    );
  }

  isTagSelected(tagValue: string): boolean {
    return this.selectedTags.includes(tagValue);
  }

  toggleTagSelection(tagValue: string): void {
    if (this.isTagSelected(tagValue)) {
      this.selectedTags = this.selectedTags.filter(t => t !== tagValue);
    } else {
      this.selectedTags = [...this.selectedTags, tagValue];
    }
  }

  // onSave(): void {
  //   this.tagsSelected.emit({
  //     tags: this.selectedTags,
  //     options: this.operationOptions
  //   });
  // }

  // onCancel(): void {
  //   this.modalClosed.emit();
  // }



  invalidTime: boolean = false;

  validateTime(): void {
    const max = this.delayUnit === 'hour' ? 24 : 60;
    this.invalidTime = this.delayTime < 1 || this.delayTime > max;
  }

  onUnitChange(): void {
    // Reset time if it exceeds new unit's max
    const max = this.delayUnit === 'hour' ? 24 : 60;
    if (this.delayTime > max) {
      this.delayTime = max;
    }
    this.validateTime();
  }


  selectedBotId: string = '';
  selectedBot: any = null;

  getSelectedBot(botId: string) {
    this.selectedBot = this.availableBots.find(bot => bot.id === botId);
    console.log('Selected Bot:', this.selectedBot);
  }


  getAdditiionalAttributes() {
    console.log('Fetching additional attributes for SPID:', this.userDetails);
    this.apiService.getAttributeList(this.userDetails?.SP_ID || 159).subscribe(allAttributes => {
      var allAttributesList: any = allAttributes
      let attributes: any = []
      allAttributesList.map((attribute: any) => {
        attributes.push('{{' + attribute?.attribute_name + '}}')
      })
      this.showAttribute = attributes
    })
  }


  openAttributeOption(index: any, field: any) {
    if (this.showAttribute?.index === index && this.showAttribute?.field === field) {
      this.showAttribute = null;
    } else {
      this.showAttribute = { index, field };
    }
  }





  createNodeHtmlForAdvanceModal(nodeId: any, nodeData: any) {
    let newHTML = ``;
    const formData = nodeData.formData || {};
    const templateHead = this.ParentNodeType == 'sendMessage' ? 'Send' : this.ParentNodeType == 'questionOption' ? 'Question' : this.ParentNodeType == 'openQuestion' ? 'Open' : this.ParentNodeType == 'buttonOptions' ? 'Button' : this.ParentNodeType == 'listOptions' ? 'List' : 'Ask';

    const temHeaderStyle = this.ParentNodeType == 'sendMessage' ? 'background:#dadee2' :
      nodeData.text === 'questionOption' || nodeData.text === 'openQuestion' || nodeData.text == 'buttonOptions' || nodeData.text == 'listOptions' ? 'background:#fce4e4' :
        nodeData.text === 'List' ? 'background:#f93' : 'background:#4bc25a';

    newHTML += `<div class="box_111" style="${temHeaderStyle}"><span class="temName">${templateHead + ' ' + this.getNodeName()}</span></div>`;


    console.log("nodeData.text", nodeData.text);
    if (this.cardType === 'sendImage' || this.cardType === 'sendVideo' || this.cardType === 'sendDocument') {
      newHTML += `<div class="textContImage">`;
      if (this.cardType === 'sendImage') {
        const imgSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
        newHTML += `<img alt="Image Preview" src="${imgSrc}" class="Preview" style="max-width: 100%;" class="mb-2" />`;
      } else if (this.cardType === 'sendVideo') {
        const videoSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
        newHTML += `<video src="${videoSrc}" class="Preview mb-2" controls style="max-width: 100%;"></video>`;
      } else if (this.cardType === 'sendDocument') {
        newHTML += `<img alt="Document Preview" src="assets/img/document.png" class="Preview" style="max-width: 100%;" class="mb-2" />`;
      }
      newHTML += `</div>`;

      if (formData.textMessage) {
        newHTML += `<div class="textCont"><p>${formData.textMessage}</p></div>`;
      }
    }
    else if (nodeData.text === 'sendText') {
      newHTML += `<div class="textCont">`;
      newHTML += `${formData.textMessage || 'Sample Text'}`;
      newHTML += `</div>`;
    }
    else if (nodeData.text === 'openQuestion') {
      newHTML += `<div class="textCont">`;
      newHTML += `${formData.questionText || 'Sample Text'}`;
      newHTML += `</div>`;
    }


    else if (nodeData.text === 'questionOption') {


      console.log("formData", formData);
      newHTML += `<div class="textQuestion">`;
      if (formData.questionText) {
        newHTML += `<h6 class="body_text">${formData.questionText}</h6>`;
      }
      newHTML += `</div>`;

      var buttonHTML: any = ``;
      if (formData?.options?.length != 0 || formData?.options != undefined) {
        formData?.options?.forEach((buttonElement: any) => {
          const uniqueId = this.generateRandom6DigitNumber();
          buttonHTML += `<button style="display:block;" class="btn btn_theme3 btn-block customButton mt-2 nodeButton-${nodeId} button_id-${uniqueId}">${buttonElement}</button>`
        });
      }

      newHTML += `<div class="buttons">${buttonHTML}</div>`;
    }

    else if (nodeData.text === 'buttonOptions') {
      newHTML += `<div class="textQuestion">`;
      if (formData.headerText) {
        newHTML += `<h6 class="body_text">${formData.headerText}</h6>`;
      }
      if (formData?.headerType === 'image' || formData?.headerType === 'video' || formData?.headerType === 'document') {
        newHTML += `<div class="textContImage">`;
        if (formData?.headerType === 'image') {
          const imgSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
          newHTML += `<img alt="Image Preview" src="${imgSrc}" class="Preview" style="max-width: 100%;" class="mb-2" />`;
        } else if (formData?.headerType === 'video') {
          const videoSrc = nodeData.file ? this.filePreview || this.selectedImageUrl : 'assets/img/not_found.jpg';
          newHTML += `<video src="${videoSrc}" class="Preview mb-2" controls style="max-width: 100%;"></video>`;
        } else if (formData?.headerType === 'document') {
          newHTML += `<img alt="Document Preview" src="assets/img/document.png" class="Preview" style="max-width: 100%;" class="mb-2" />`;
        }
        newHTML += `</div>`;
      }
      if (formData?.bodyText) {
        newHTML += `<h6 class="body_text">${formData.bodyText || 'Sample Body Text'}</h6>`;
      }
      if (formData?.footerText) {
        newHTML += `<h6 class="body_text">${formData.footerText}</h6>`;
      }
      newHTML += `</div>`;

      var buttonHTML: any = ``;
      if (formData?.buttons?.length != 0 || formData?.buttons != undefined) {
        formData?.buttons?.forEach((buttonElement: any) => {
          const uniqueId = this.generateRandom6DigitNumber();
          buttonHTML += `<button style="display:block;" class="btn btn_theme3 btn-block customButton mt-2 nodeButton-${nodeId} button_id-${uniqueId}">${buttonElement}</button>`
        });
      }

      newHTML += `<div class="buttons">${buttonHTML}</div>`;


    }



    else if (nodeData.text === 'listOptions') {
      newHTML += `<div class="textQuestion">`;

      if (formData.headerText) {
        newHTML += `<h6 class="body_text">${formData.headerText}</h6>`;
      }


      // console.log(newHTML, "newHTML");
      if (formData.bodyText) {
        newHTML += `<h6 class="body_text">${formData.bodyText}</h6>`;
      }

      if (formData.footerText) {
        newHTML += `<h6 class="body_text">${formData.footerText}</h6>`;
      }
      newHTML += `</div>`;

      if (formData.listHeader) {
        newHTML += `<h6 class="listHeader text-center text-primary font-semibold underline my-2">${formData.listHeader}</h6>`;
      }

      // Section blocks
      if (formData?.sections?.length > 0) {
        formData.sections.forEach((section: any) => {
          newHTML += `<div class="section-card" style="background:#FFF4F2; padding: 10px; margin-bottom: 12px; border-radius: 12px;">`;

          if (section.sectionHeading) {
            newHTML += `<h6 class="section-heading font-semibold text-center mb-2" >${section.sectionHeading}</h6>`;
          }

          if (section.rows?.length > 0) {
            section.rows.forEach((row: any) => {
              const uniqueId = this.generateRandom6DigitNumber();
              newHTML += `
            <div class="option-row flex justify-between items-center bg-white p-2 rounded-md shadow-sm mb-2 nodeButton-${nodeId} button_id-${uniqueId}" style=" background: #F7F7F7 !important;border: 1px solid #d7bcbc;border-radius: 13px;">
              <span>${row.rowName}</span>
              <span class="dot bg-green-500 w-3 h-3 rounded-full"></span>
            </div>
          `;
            });
          }

          newHTML += `</div>`;
        });
      }

    }
    newHTML += `<div class="viewSection"><img src="assets/img/edit.png" style="cursor:pointer" class="ViewNode editNode"></div>`;
    newHTML += `<div class="viewSectioncopy"><img src="assets/img/teambox/copy.svg" style="cursor:pointer" class="ViewNode copyNode"></div>`;

    return newHTML;
  }





















































  CheckSampleValue: any = ['Sample Header Text', 'Sample Footer Text', 'Sample Body Text'];
  inputArray: any = []
  outputArray: any = []
  async saveChatbot() {
    this.orignalData = {};

    const exportData: any = this.editor.export();
    let exportNodsData: any = Object.values(exportData?.drawflow?.Home?.data);
    const nodes = document.querySelectorAll('.drawflow-node');
    const chatBotData: any = [];
    let isNodeHaveConnected: any = true
    this.inputArray = [];
    this.outputArray = [];

    nodes.forEach((node) => {
      const nodeId: any = node.getAttribute('id');
      const nodeContent = node.querySelector('.drawflow_content_node');
      const nodeData: any = { id: Number(nodeId.split('-')[1]) };
      const findNode: any = exportNodsData.find(
        (x: any) => x.id == nodeData.id
      );

      // console.log("findNode", findNode)
      // if (isNodeHaveConnected) {
      isNodeHaveConnected = this.checkNodeHaveConnection(findNode);
      // }

      var flowData = this.getFullFlowJson()

      console.log("flowData", flowData)
      




    })
      


  }


  updateCharacterCount() {
    const message = this.notificationForm.get('textMessage')?.value || '';
    this.characterCount = message.replace(/<[^>]*>/g, '').length;
  }


  checkNodeHaveConnection(node: any) {

 
      Object.keys(node.inputs).forEach((inputKey) => {
        if (node.inputs[inputKey].connections.length == 0) { this.inputArray.push(true) } else { this.inputArray.push(false) }
      });

      Object.keys(node.outputs).forEach((inputKey) => {
        if (node.outputs[inputKey].connections.length == 0) { this.outputArray.push(true) } else { this.outputArray.push(false) }
      });

      let isInputConnected = this.inputArray.some((item: any) => item == true)
      let isOutputConnected = this.outputArray.some((item: any) => item == true)
      if (isInputConnected && isOutputConnected) {
        return false;
      }
      return true;
    }


    getFullFlowJson(): any {
  const exportData = this.editor.export();
  const flowData: any = {
    nodes: [],
    connections: []
  };
  
  // Process all nodes
  Object.entries(exportData.drawflow.Home.data).forEach(([id, node]: [string, any]) => {
    flowData.nodes.push({
      id: node.id,
      name: node.name,
      type: node.data.text,
      category: node.data.category,
      data: node.data.formData,
      position: {
        x: node.pos_x,
        y: node.pos_y
      }
    });
    
    // Process connections
    Object.entries(node.outputs).forEach(([outputKey, output]: [string, any]) => {
      output.connections.forEach((connection: any) => {
        console.log("connection", connection)
        flowData.connections.push({
          sourceNode: node.id,
          sourceOutput: outputKey,
          targetNode: connection.node,
          targetInput: connection.output
        });
      });
    });
  });
  
  return flowData;
}
  

}



// Initialize form


